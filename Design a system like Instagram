1-) What this system looks like?

  i-) This system is used for uploading image and sharing this image to any other users. 
    This means that users can share images and other users who follow this user can see user's images.
  ii-) Notice that users have a timeline that all of their images list here.

2-) Requirements and goals

  i-) Users can upload images and others can see these images.
  ii-) Users can follow other users
  iii-) Users can delete their images.
  iiii-) Users have a timeline (Notice that 200 ms is ok for generation timeline)
  iiiii-) Users can accept or ignore the other user's follow-up request
  iiiiii-) System should be highly reliable. This means that any image should not be lost. (with replication)
  iiiiiii-) System should be highly available. This means that every user should reach the images whenever they want (with one more servers)
  iiiiiiii-) System should be work with minimum latency. (with partition, load balancer etc.)
  iiiiiiiii-) Rest API can be used for this application.
  iiiiiiiiii-) Notice that system can be monitored with some of added informations such as locations, access time, upload time etc.
  iiiiiiiiiii-) Users can search images with titles.
  
3-) Capacity Estimation
    a-)Storage
    
      1-) Notice that if system has 500 Million users and 1 Million users upload 2 images in one day.
        If we assume that average image size 200 KB then one day capacity = 2M * 200 KB = 400 GB for every day. 
        In 10 years => 400 GB * 365 * 10 ~= 1500 TB (huge data)
    
    b-) Cache
      
        1-) If we use %20 principle for caching mechanism. Then one day capacity * 0.2 is for cache memory => 400 GB * 0.2 = 80 GB
        
  4-) API's and Database
  
    * We can use REST API's for this system. Basically UploadImage, DeleteImage, SearchImage, FollowUser, GetImages are necessity 
    API's for this system.
    
    * For database, we can use NoSql because there will be millions of datas and latency is more important. We can prefer
    MongoDB or Cassandra for creating this system. With NoSql there are basically four tables should be, First one is (Photos),
    second one is (Users) and third one is (Images and Users) and final one is (User and Follows). 
    
  5-) High Level System Design
  
    *  Notice that most of servers have a connection limits at the same time. 
    *  Upload files are much slower operation than download files (if files are in cache memory)
    *  We can implement our system with split the request operations to other services (upload services and download services)
    *  Upload services can syncronious but download services can be asyncronious is good idea.
    * If we redirect the upload request and download request different servers then even if the system is busy, users can see the photos.
    * We should save the copy of files to prevent data lost. (replication )
    * In replication system we replicate one server with two or more other servers.
    * Notice that copy of datas should not be saved in same server.
    * Additionally, for minimum latency we can divide image database to metadata database and image stroge (real information)
    
  6-) Sharding and Partition

    * Sharding can be created by UserID or PhotoID. If we think that each shard is 5 TB then 300 shard has enough for this system.
    * If we shard by UserID then we will find UserID % 300 to suitable shard.
    * Notice that if the system is shard by userID then, this system can be unbalanced because some users share much more images then others.
    * So we can prefer sharding by PhotoID. Notice that PhotoID can be created by Key generation services. 
    * Key generation services create the keys first then these values saved in Key Database. (For minimum latency and eliminate duplication)
  
  7-) Caching
  
    * The caching operation can be used for metadata server. (CDN)
    * Additionally we can use Least recently Used operation for caching mechanism.
 

