
1-) INTRODUCING

- Firstly we should cover some of the important issues. Firstly, we should clarify the system design very well. Additionally we can determine
the type of databases (NoSql or RDBMS) and limitiations of limit be carefully

- Like youtube, this system provides users to share or watch video on cloud platform. Additionally, user can make comment or get the point
to video or fallow the other users when using this cloud web application.

2-) REQUIREMENTS AND GOALS OF THE SYSTEM

- There are three types of requirements. These are functional, nonfunctional and extended requirements.

- Functional requirements
  
  i-) User can login and logout
  ii-) User can upload videos and share videos
  iii-) User can watch videos 
  iv-) User can give the rate of videos.
  v-) User can like or dislike the photos.
  vi-) Users can see the watching number of video.
  vii-) User can add or view comments.
  
 - Nonfunctional requirements
 
  i-) System should be highly reliable, this means that uploading videos cannot be losted. This necessity can be provided by using the replication
  ii-) System should be highly avaliable. This means that user should reach the system whenever you want. Also system should have a 
  minimum latency. Notice that we can choose the CAP Theorem when designing the system, so this system will be acceptable if some of videos 
  does not be seen for a while. (Notice that this is partition tolerance, system should always work.)
  iii-) System should work with minimum latency. (This functionality is provided with data partition and sharding)
  
  - Extended requirements
  
  i-) We can design related web application with REST APIs. Additionally, we can keep the watching video time or watching location to monitorize 
  the system. Additionaly, we can use monitoring to keep track of system usage. Notice that Azure provides us to this functionalities.
  If anyone use the azure platform, Azure looks the CPU usage and if maximum usage rate is reached, Azure automatically add new nodes. (Example 
  of Azure)
  
 3-) CAPACİTY AND ESTIMATION
 
 General Estimates
 ----------
 - If this web application has 100 million active users per day and the average number of watching video per user is 5.
 - One second viewing video = 100M * 5 / 3600 = (approximately) 6K videos / second
 
 Now lets assume that the ratio of uploading and downloading videos is 1 : 100. So,
 - One second uploading video = 6K / 100 = 60 videos /second
 
 Storage Estimates
 -------------
 - Now, let's assume that totally, 100 hours video is uploading per day. This means that, additionally, 1 minute video has 100 MB so,
 
 100 * 60 * 100 MB = 60000 MB This means that 60 GB per day to need to keep the data of video. Notice that, this number does not deal with
 the replication of data or metadatas or information of users. Now, if we try to estimate the total capacity of system after the 5 years,
 then this is too much to store data. (with replication and metadatas.)
 
 4-) SYSTEM API's
 
 We can use REST API's to provide connections. (backend vs mobile and frontend). Additionally, we have mainly two APIs. First one is
 searchVideo and second one is uploadVideo. Notice that all of these API's has API_KEY to provide security (registered account for users).
 
 uploadVideo(apiKey, title, description, language, details, contents)
 searchVideo(apiKey, searchTitle, location, maximumVideoCount)
 
 Notice that location is an optional and it is used for increasing the performing.
 Also notice that JSON format is used to returning datas.
 
 5-) HIGH LEVEL DESIGN BASICALLY
 
  - Users
  - Web Server
  - Application Server
  - Encoder
  - User Database server
  - Vdeo Database server
  - Metadata server
  
  If we imagine the flow of user request;
  
  When user search, upload or view data, request firstly comes to web server. Web server is just to handle http request. The main
  duty of web server is related to http request. After the web server, request comes to application server. Application server 
  connects with the user database, metadabase, encoder and video database. Notice that metadata database keep the detail information of 
  video such as users that upload viode, or video time, or video language etc..
  
  Additionally encoder's main duty is the chancing the video type to multiple formats to provide watching the video properly. This operation 
  actualizes with the queue operations. 
 
 6-) DATABASE SCHEMA
 
 Notice that we hava three database servers. First one is related to user second one is related to video content and thir one is related
 to video metadata. We can save the datas with MySql. User data has userId,Name,Surname,Mail,RegistrationDate and Video has VİdeoID, Title,
 Description, Size, Thumbnail, Number of likes, Uploader(User), Number of Dislikes and number of Views. Additionally we should be careful
 to design database. 3NF form should be used in database schema. Becucase of that, we can keep comment of video in the seperate data. 
 Additioanlly we can keep the users that view,like, dislike the videos in separate tables. Onemore information about the database is
 Mysql is the RDBMS and this basically supports the ACID Thorem. Also videos can be stored in a distributed file storage system.
 
 7-) DETAILED HIGH LEVEL DESIGN
 
  - Client
  - Proxy Server
  - Web Server
  - Application Server
  - User Database Server
  - MetaData database server
  - Encode
  - ThumbNail Storage
  - Video Storage
  - Video Cache
  - CDN (Content Delivery Network)
  
  If we imagine the flow of user request, client can upload, search or view. These request firstly come to proxy server. Proxy server
  can have caching mecahinism and if they find the video then it can return the video. Otherwise, Request comes to web server. Web server 
  handles the http requests and transfer the request to application server. Application server has connections with user management, metadata
  database and encode. Additionally applicaton server has a connection with video storage. Notice that we add new level that is video caching.
  Moreover we add CDN. Onemore, we can seperate read and write request servers to increase the performance.
  
  8-) SHARDING
  
  Because of the huge data that need to be stored, we need to distribute datas onto multiple servers to increase the performance.
  We can shard based on userID and shard based on videoID. If we shard datas based on the userID. maybe the uniformly distributed cannot be 
  occured. Because what if some user has more popular than others. In this state, some of servers have much more datas than others. Additionally,
  at this stage, much more request can come to these servers and this stuations affects performance badly. Additionally, if we prefer the 
  sharding based on videoID then, we need to centrilazed server to rank the (specific)users video because we obtain the datas maybe all of servers.
  
  9-) VIDEO DEDUPLICATION
  
  If some users update same videos, what do we should do. Maybe we can work with video matching algorithm and if this algorithm find the 
  same video, then can compare these videos based on quality. If the qualtiy of new video is higher than the older then, older video will be
  deleted and new video will uploaded. Otherwise operation will be stopped.
  
  10-) LOAD BALANCING
  
  we should use load balancer to provide data redundancy. We can use load balancer for web servers, application servers, metadata servers and 
  thumbnail servers. We can prefer round robin algorithm to load balancing but this is not good idea since round robin algorithm
  cannot be eliminate the request when server is busy or not suitable, so we can prefer intelligent round roibn algorithm to stop the
  sending request a server that is busy or not working.
  
  11-) CACHING
  
  We can prefer %20 %80 rule to apply caching. This means that if we have 100 GB datas then we use caching with 20 GB storage. Notice that
  we can prefer LRU (Least recently used) algorithm for caching. Addıtıonally, we should put the death time of the caching data becaseu of providing
  consistency. Caching mechanism can be used for metadata and video storage database. Additionally, our main approach to using caching is
  increasing the performance. We use mamcache or .NET cache systems to implement caching. But mamcache is distributed. .NET cache system is not
  distributed. If you have one more cluster of servers then I think you should choose memcache otherwise you should choose .NET cache, because of 
  performance.
  
  12-)  CONTENT DELIVERY NETWORK (CDN)
  
  CDN is basically used for media storages and files. CDN is distributed and main approaxh of CDN is increasing the performance while
  reaching the data. Notice that CDN makes use of the caching operation too much.
  
 
 
 
 
 
 
  
  
